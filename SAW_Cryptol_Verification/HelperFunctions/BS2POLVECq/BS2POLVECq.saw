enable_experimental;

include "helpers.saw";
import "BS2POLVECq.cry";

// 1. Load the compiled C module
bs2polvecq_mod <- llvm_load_module "BS2POLVECq.bc";

// 2. Verification specification block
let bs2polvecq_ok = do {
  let packed_len = 1040;  // 3 * 256 * 13 / 8
  let saber_k = 3;
  let saber_n = 256;

  // Symbolic input and output
  (bytes, bytes_ptr) <- ptr_to_fresh "bytes" (llvm_array packed_len (llvm_int 8));
  (_, data_ptr) <- ptr_to_fresh "data" (llvm_array saber_k (llvm_array saber_n (llvm_int 16)));

  // Execute the function
  llvm_execute_func [bytes_ptr, data_ptr];

  // Expected result from Cryptol
  let result_spec = {{ bs2polvecq_u16 bytes }};
  llvm_points_to data_ptr (llvm_term {{ result_spec }});
};

// 3. Run the proof with Yices
llvm_verify bs2polvecq_mod "BS2POLVECq" [] true bs2polvecq_ok yices;
print "[âœ”] Proof succeeded!";

